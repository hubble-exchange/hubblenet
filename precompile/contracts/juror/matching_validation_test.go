// Code generated
// This file is a generated precompile contract test with the skeleton of test functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package juror

import (
	"fmt"
	"math/big"

	"testing"

	ob "github.com/ava-labs/subnet-evm/plugin/evm/orderbook"
	hu "github.com/ava-labs/subnet-evm/plugin/evm/orderbook/hubbleutils"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/assert"

	b "github.com/ava-labs/subnet-evm/precompile/contracts/bibliophile"
	gomock "github.com/golang/mock/gomock"
)

func TestValidateLimitOrderLike(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	order := &ob.BaseOrder{
		AmmIndex:          big.NewInt(0),
		Trader:            trader,
		BaseAssetQuantity: big.NewInt(10),
		Price:             big.NewInt(20),
		Salt:              big.NewInt(1),
		ReduceOnly:        false,
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("Side=Long", func(t *testing.T) {
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(gomock.Any()).Return(common.Address{}).AnyTimes()
		t.Run("OrderStatus != Placed will throw error", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Invalid, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Filled, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Cancelled, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())
		})

		t.Run("base asset quantity <= 0", func(t *testing.T) {
			badOrder := *order
			badOrder.BaseAssetQuantity = big.NewInt(-23)

			err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrNotLongOrder.Error())

			badOrder.BaseAssetQuantity = big.NewInt(0)
			err = validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrNotLongOrder.Error())
		})

		t.Run("ErrOverFill", func(t *testing.T) {
			fillAmount := big.NewInt(6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrOverFill.Error())
		})

		t.Run("negative fillAmount", func(t *testing.T) {
			fillAmount := big.NewInt(-6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidFillAmount.Error())
		})

		t.Run("ErrReduceOnlyAmountExceeded", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			for i := int64(10); /* any +ve # */ i > new(big.Int).Neg(fillAmount).Int64(); i-- {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
				assert.EqualError(t, err, ErrReduceOnlyAmountExceeded.Error())
			}
		})

		t.Run("all conditions met for reduceOnly order", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			start := new(big.Int).Neg(fillAmount).Int64()
			for i := start; i > start-5; i-- {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
				assert.Nil(t, err)
			}
		})

		t.Run("all conditions met", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.Nil(t, err)
		})
	})

	t.Run("Side=Short", func(t *testing.T) {
		order := &ob.BaseOrder{
			AmmIndex:          big.NewInt(0),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(-10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		}
		filledAmount := big.NewInt(-5)
		fillAmount := big.NewInt(-5)
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(gomock.Any()).Return(common.Address{}).AnyTimes()
		t.Run("OrderStatus != Placed will throw error", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Invalid, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Filled, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Cancelled, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())
		})

		t.Run("base asset quantity >= 0", func(t *testing.T) {
			badOrder := *order
			badOrder.BaseAssetQuantity = big.NewInt(23)

			err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrNotShortOrder.Error())

			badOrder.BaseAssetQuantity = big.NewInt(0)
			err = validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrNotShortOrder.Error())
		})

		t.Run("positive fillAmount", func(t *testing.T) {
			fillAmount := big.NewInt(6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidFillAmount.Error())
		})

		t.Run("ErrOverFill", func(t *testing.T) {
			fillAmount := big.NewInt(-6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrOverFill.Error())
		})

		t.Run("ErrReduceOnlyAmountExceeded", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			for i := int64(-10); /* any -ve # */ i < new(big.Int).Abs(fillAmount).Int64(); i++ {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
				assert.EqualError(t, err, ErrReduceOnlyAmountExceeded.Error())
			}
		})

		t.Run("all conditions met for reduceOnly order", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			start := new(big.Int).Abs(fillAmount).Int64()
			for i := start; i < start+5; i++ {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
				assert.Nil(t, err)
			}
		})

		t.Run("all conditions met", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.Nil(t, err)
		})
	})

	t.Run("invalid side", func(t *testing.T) {
		order := &ob.BaseOrder{
			AmmIndex:          big.NewInt(0),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		}
		filledAmount := big.NewInt(0)
		fillAmount := big.NewInt(5)

		err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Side(4), fillAmount) // assuming 4 is an invalid Side value
		assert.EqualError(t, err, "invalid side")
	})
}

func TestValidateExecuteLimitOrder(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)
	marketAddress := common.HexToAddress("0xa72b463C21dA61cCc86069cFab82e9e8491152a0")
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")

	order := &ob.LimitOrder{
		BaseOrder: ob.BaseOrder{
			AmmIndex:          big.NewInt(534),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		},
		PostOnly: false,
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("validateExecuteLimitOrder", func(t *testing.T) {
		orderHash, err := order.Hash()
		assert.Nil(t, err)

		blockPlaced := big.NewInt(42)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(filledAmount).Times(1)
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)).Times(1)                                 // placed
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(blockPlaced).Times(1)                              // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(marketAddress).Times(1) // placed

		m, err := validateExecuteLimitOrder(mockBibliophile, order, Long, fillAmount, orderHash)
		assert.Nil(t, err)
		assertMetadataEquality(t, &Metadata{
			AmmIndex:          new(big.Int).Set(order.AmmIndex),
			Trader:            trader,
			BaseAssetQuantity: new(big.Int).Set(order.BaseAssetQuantity),
			BlockPlaced:       blockPlaced,
			Price:             new(big.Int).Set(order.Price),
			OrderHash:         orderHash,
		}, m)
	})
}

func assertMetadataEquality(t *testing.T, expected, actual *Metadata) {
	assert.Equal(t, expected.AmmIndex.Int64(), actual.AmmIndex.Int64())
	assert.Equal(t, expected.Trader, actual.Trader)
	assert.Equal(t, expected.BaseAssetQuantity, actual.BaseAssetQuantity)
	assert.Equal(t, expected.BlockPlaced, actual.BlockPlaced)
	assert.Equal(t, expected.Price, actual.Price)
	assert.Equal(t, expected.OrderHash, actual.OrderHash)
}

func TestDetermineFillPrice(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	oraclePrice := hu.Mul1e6(big.NewInt(20))                                                               // $10
	spreadLimit := new(big.Int).Mul(big.NewInt(50), big.NewInt(1e4))                                       // 50%
	upperbound := hu.Div1e6(new(big.Int).Mul(oraclePrice, new(big.Int).Add(big.NewInt(1e6), spreadLimit))) // $10
	lowerbound := hu.Div1e6(new(big.Int).Mul(oraclePrice, new(big.Int).Sub(big.NewInt(1e6), spreadLimit))) // $30
	market := int64(5)

	t.Run("long order came first", func(t *testing.T) {
		blockPlaced0 := big.NewInt(69)
		blockPlaced1 := big.NewInt(70)
		t.Run("long price < lower bound", func(t *testing.T) {
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(9)),
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(8)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooLow, err)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(7)),
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(7)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooLow, err)
			})
		})

		t.Run("long price == lower bound", func(t *testing.T) {
			longPrice := lowerbound
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("lowerbound < long price < oracle", func(t *testing.T) {
			longPrice := hu.Mul1e6(big.NewInt(15))
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("long price == oracle", func(t *testing.T) {
			longPrice := oraclePrice
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("oracle < long price < upper bound", func(t *testing.T) {
			longPrice := hu.Mul1e6(big.NewInt(25))
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("long price == upper bound", func(t *testing.T) {
			longPrice := upperbound
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("upper bound < long price", func(t *testing.T) {
			longPrice := new(big.Int).Add(upperbound, big.NewInt(42))
			t.Run("upper < short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Add(upperbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooHigh, err)
			})

			t.Run("upper == short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       upperbound,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})

			t.Run("short price < upper", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(upperbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})

			t.Run("short price < lower", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(lowerbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})
		})
	})
}

func TestDetermineLiquidationFillPrice(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	liqUpperBound, liqLowerBound := hu.Mul1e6(big.NewInt(22)), hu.Mul1e6(big.NewInt(18))

	upperbound := hu.Mul1e6(big.NewInt(30)) // $30
	lowerbound := hu.Mul1e6(big.NewInt(10)) // $10
	market := int64(7)

	t.Run("long position is being liquidated", func(t *testing.T) {
		t.Run("order price < liqLowerBound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Sub(liqLowerBound, big.NewInt(1)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, output)
			assert.Equal(t, ErrTooLow, err)
		})
		t.Run("order price == liqLowerBound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             liqLowerBound,
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, liqLowerBound, output)
		})

		t.Run("liqLowerBound < order price < upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Add(liqLowerBound, big.NewInt(99)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, m0.Price, output)
		})

		t.Run("order price == upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             upperbound,
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, upperbound, output)
		})

		t.Run("order price > upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Add(upperbound, big.NewInt(99)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, upperbound, output)
		})
	})
}

type ValidateOrdersAndDetermineFillPriceTestCase struct {
	Order0, Order1 ob.ContractOrder
	FillAmount     *big.Int
	Err            error
	BadElement     BadElement
}

func testValidateOrdersAndDetermineFillPriceTestCase(t *testing.T, mockBibliophile *b.MockBibliophileClient, testCase ValidateOrdersAndDetermineFillPriceTestCase) ValidateOrdersAndDetermineFillPriceOutput {
	order0Bytes, err := testCase.Order0.EncodeToABI()
	if err != nil {
		t.Fatal(err)
	}
	order1Bytes, err := testCase.Order1.EncodeToABI()
	if err != nil {
		t.Fatal(err)
	}
	resp := ValidateOrdersAndDetermineFillPrice(mockBibliophile, &ValidateOrdersAndDetermineFillPriceInput{
		Data:       [2][]byte{order0Bytes, order1Bytes},
		FillAmount: testCase.FillAmount,
	})

	// verify results
	if testCase.Err == nil && resp.Err != "" {
		t.Fatalf("expected no error, got %v", resp.Err)
	}
	if testCase.Err != nil {
		if resp.Err != testCase.Err.Error() {
			t.Fatalf("expected %v, got %v", testCase.Err, testCase.Err)
		}

		if resp.Element != uint8(testCase.BadElement) {
			t.Fatalf("expected %v, got %v", testCase.BadElement, resp.Element)
		}
	}
	return resp
}

func TestValidateOrdersAndDetermineFillPrice(t *testing.T) {
	// create a mock BibliophileClient
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	t.Run("invalid fillAmount", func(t *testing.T) {
		order0 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		fillAmount := big.NewInt(0)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrInvalidFillAmount,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("different amm", func(t *testing.T) {
		order0 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(1),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{102})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))
		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrNotSameAMM,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("price mismatch", func(t *testing.T) {
		order0 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(99),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))
		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrNoMatch,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("fillAmount not multiple", func(t *testing.T) {
		order0 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))

		mockBibliophile.EXPECT().GetMinSizeRequirement(order1.AmmIndex.Int64()).Return(big.NewInt(5))

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrNotMultiple,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("success", func(t *testing.T) {
		order0 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))

		mockBibliophile.EXPECT().GetMinSizeRequirement(order1.AmmIndex.Int64()).Return(big.NewInt(1))
		mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(order1.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        nil,
			BadElement: NoError,
		}

		response := testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
		assert.Equal(t, big.NewInt(100), response.Res.FillPrice)
		assert.Equal(t, uint8(0), response.Res.OrderTypes[0])
		assert.Equal(t, uint8(0), response.Res.OrderTypes[1])

		assert.Equal(t, uint8(NoError), response.Element)
		assert.Equal(t, IClearingHouseInstruction{
			AmmIndex:  big.NewInt(0),
			Trader:    trader,
			OrderHash: order0Hash,
			Mode:      uint8(Maker),
		}, response.Res.Instructions[0])
		assert.Equal(t, IClearingHouseInstruction{
			AmmIndex:  big.NewInt(0),
			Trader:    trader,
			OrderHash: order1Hash,
			Mode:      uint8(Taker),
		}, response.Res.Instructions[1])
	})
}

type ValidateLiquidationOrderAndDetermineFillPriceTestCase struct {
	Order             ob.ContractOrder
	LiquidationAmount *big.Int
	Err               error
	BadElement        BadElement
}

func testValidateLiquidationOrderAndDetermineFillPriceTestCase(t *testing.T, mockBibliophile *b.MockBibliophileClient, testCase ValidateLiquidationOrderAndDetermineFillPriceTestCase) ValidateLiquidationOrderAndDetermineFillPriceOutput {
	orderBytes, err := testCase.Order.EncodeToABI()
	if err != nil {
		t.Fatal(err)
	}

	resp := ValidateLiquidationOrderAndDetermineFillPrice(mockBibliophile, &ValidateLiquidationOrderAndDetermineFillPriceInput{
		Data:              orderBytes,
		LiquidationAmount: testCase.LiquidationAmount,
	})

	// verify results
	if testCase.Err == nil && resp.Err != "" {
		t.Fatalf("expected no error, got %v", resp.Err)
	}
	if testCase.Err != nil {
		if resp.Err != testCase.Err.Error() {
			t.Fatalf("expected %v, got %v", testCase.Err, testCase.Err)
		}

		if resp.Element != uint8(testCase.BadElement) {
			t.Fatalf("expected %v, got %v", testCase.BadElement, resp.Element)
		}
	}
	return resp
}

func TestValidateLiquidationOrderAndDetermineFillPrice(t *testing.T) {
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	t.Run("invalid liquidationAmount", func(t *testing.T) {
		order := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        true,
			},
			PostOnly: false,
		}

		mockBibliophile := b.NewMockBibliophileClient(ctrl)

		testCase := ValidateLiquidationOrderAndDetermineFillPriceTestCase{
			Order:             order,
			LiquidationAmount: big.NewInt(0),
			Err:               ErrInvalidFillAmount,
			BadElement:        Generic,
		}

		testValidateLiquidationOrderAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("fillAmount not multiple", func(t *testing.T) {
		order := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        true,
			},
			PostOnly: false,
		}
		orderHash, _ := order.Hash()

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(big.NewInt(10))
		mockBibliophile.EXPECT().GetSize(common.Address{101}, &trader).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetMinSizeRequirement(order.AmmIndex.Int64()).Return(big.NewInt(5))

		testCase := ValidateLiquidationOrderAndDetermineFillPriceTestCase{
			Order:             order,
			LiquidationAmount: big.NewInt(2),
			Err:               ErrNotMultiple,
			BadElement:        Generic,
		}

		testValidateLiquidationOrderAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("success", func(t *testing.T) {
		order := &ob.LimitOrder{
			BaseOrder: ob.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        true,
			},
			PostOnly: false,
		}
		orderHash, _ := order.Hash()

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(big.NewInt(10))
		mockBibliophile.EXPECT().GetSize(common.Address{101}, &trader).Return(big.NewInt(10))
		mockBibliophile.EXPECT().GetMinSizeRequirement(order.AmmIndex.Int64()).Return(big.NewInt(1))
		mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(order.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))
		mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(order.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))

		testCase := ValidateLiquidationOrderAndDetermineFillPriceTestCase{
			Order:             order,
			LiquidationAmount: big.NewInt(2),
			Err:               nil,
			BadElement:        NoError,
		}

		response := testValidateLiquidationOrderAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)

		assert.Equal(t, uint8(NoError), response.Element)
		assert.Equal(t, IClearingHouseInstruction{
			AmmIndex:  big.NewInt(0),
			Trader:    trader,
			OrderHash: orderHash,
			Mode:      uint8(Maker),
		}, response.Res.Instruction)
		assert.Equal(t, big.NewInt(100), response.Res.FillPrice)
		assert.Equal(t, uint8(0), response.Res.OrderType)
		assert.Equal(t, big.NewInt(-2), response.Res.FillAmount)
	})
}

func TestReducesPosition(t *testing.T) {
	testCases := []struct {
		positionSize      *big.Int
		baseAssetQuantity *big.Int
		expectedResult    bool
	}{
		{
			positionSize:      big.NewInt(100),
			baseAssetQuantity: big.NewInt(-50),
			expectedResult:    true,
		},
		{
			positionSize:      big.NewInt(-100),
			baseAssetQuantity: big.NewInt(50),
			expectedResult:    true,
		},
		{
			positionSize:      big.NewInt(100),
			baseAssetQuantity: big.NewInt(50),
			expectedResult:    false,
		},
		{
			positionSize:      big.NewInt(-100),
			baseAssetQuantity: big.NewInt(-50),
			expectedResult:    false,
		},
	}

	for _, tc := range testCases {
		result := reducesPosition(tc.positionSize, tc.baseAssetQuantity)
		if result != tc.expectedResult {
			t.Errorf("reducesPosition(%v, %v) = %v; expected %v", tc.positionSize, tc.baseAssetQuantity, result, tc.expectedResult)
		}
	}
}

func TestGetRequiredMargin(t *testing.T) {
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)
	mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(gomock.Any()).Return(big.NewInt(100), big.NewInt(10)).AnyTimes()
	mockBibliophile.EXPECT().GetMinAllowableMargin().Return(big.NewInt(1000)).AnyTimes()
	mockBibliophile.EXPECT().GetTakerFee().Return(big.NewInt(5)).AnyTimes()

	// create a mock order
	order := ILimitOrderBookOrder{
		AmmIndex:          big.NewInt(0),
		Trader:            trader,
		BaseAssetQuantity: hu.Mul(big.NewInt(10), hu.ONE_E_18),
		Price:             hu.Mul(big.NewInt(50), hu.ONE_E_6),
		ReduceOnly:        false,
		Salt:              big.NewInt(1),
		PostOnly:          false,
	}

	// call the function
	requiredMargin := getRequiredMargin(mockBibliophile, order)

	fmt.Println("#####", requiredMargin)

	// assert that the result is correct
	expectedMargin := big.NewInt(502500) // (10 * 50 * 1e6) * (1 + 0.005)
	assert.Equal(t, expectedMargin, requiredMargin)
}
