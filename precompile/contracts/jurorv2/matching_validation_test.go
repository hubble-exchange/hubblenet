// Code generated
// This file is a generated precompile contract test with the skeleton of test functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package jurorv2

import (
	"encoding/hex"
	"fmt"
	"math/big"
	"strings"

	"testing"

	hu "github.com/ava-labs/subnet-evm/hubbleutils"
	ob "github.com/ava-labs/subnet-evm/plugin/evm/orderbook"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/assert"

	b "github.com/ava-labs/subnet-evm/precompile/contracts/bibliophile"
	gomock "github.com/golang/mock/gomock"
)

func TestValidateLimitOrderLike(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	order := &hu.BaseOrder{
		AmmIndex:          big.NewInt(0),
		Trader:            trader,
		BaseAssetQuantity: big.NewInt(10),
		Price:             big.NewInt(20),
		Salt:              big.NewInt(1),
		ReduceOnly:        false,
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("Side=Long", func(t *testing.T) {
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(gomock.Any()).Return(common.Address{}).AnyTimes()
		t.Run("OrderStatus != Placed will throw error", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Invalid, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Filled, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Cancelled, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())
		})

		t.Run("base asset quantity <= 0", func(t *testing.T) {
			badOrder := *order
			badOrder.BaseAssetQuantity = big.NewInt(-23)

			err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrNotLongOrder.Error())

			badOrder.BaseAssetQuantity = big.NewInt(0)
			err = validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrNotLongOrder.Error())
		})

		t.Run("ErrOverFill", func(t *testing.T) {
			fillAmount := big.NewInt(6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrOverFill.Error())
		})

		t.Run("negative fillAmount", func(t *testing.T) {
			fillAmount := big.NewInt(-6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.EqualError(t, err, ErrInvalidFillAmount.Error())
		})

		t.Run("ErrReduceOnlyAmountExceeded", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			for i := int64(10); /* any +ve # */ i > new(big.Int).Neg(fillAmount).Int64(); i-- {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
				assert.EqualError(t, err, ErrReduceOnlyAmountExceeded.Error())
			}
		})

		t.Run("all conditions met for reduceOnly order", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			start := new(big.Int).Neg(fillAmount).Int64()
			for i := start; i > start-5; i-- {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Long, fillAmount)
				assert.Nil(t, err)
			}
		})

		t.Run("all conditions met", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Long, fillAmount)
			assert.Nil(t, err)
		})
	})

	t.Run("Side=Short", func(t *testing.T) {
		order := &hu.BaseOrder{
			AmmIndex:          big.NewInt(0),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(-10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		}
		filledAmount := big.NewInt(-5)
		fillAmount := big.NewInt(-5)
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(gomock.Any()).Return(common.Address{}).AnyTimes()
		t.Run("OrderStatus != Placed will throw error", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Invalid, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Filled, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())

			err = validateLimitOrderLike(mockBibliophile, order, filledAmount, Cancelled, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidOrder.Error())
		})

		t.Run("base asset quantity >= 0", func(t *testing.T) {
			badOrder := *order
			badOrder.BaseAssetQuantity = big.NewInt(23)

			err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrNotShortOrder.Error())

			badOrder.BaseAssetQuantity = big.NewInt(0)
			err = validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrNotShortOrder.Error())
		})

		t.Run("positive fillAmount", func(t *testing.T) {
			fillAmount := big.NewInt(6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrInvalidFillAmount.Error())
		})

		t.Run("ErrOverFill", func(t *testing.T) {
			fillAmount := big.NewInt(-6)

			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.EqualError(t, err, ErrOverFill.Error())
		})

		t.Run("ErrReduceOnlyAmountExceeded", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			for i := int64(-10); /* any -ve # */ i < new(big.Int).Abs(fillAmount).Int64(); i++ {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
				assert.EqualError(t, err, ErrReduceOnlyAmountExceeded.Error())
			}
		})

		t.Run("all conditions met for reduceOnly order", func(t *testing.T) {
			badOrder := *order
			badOrder.ReduceOnly = true

			start := new(big.Int).Abs(fillAmount).Int64()
			for i := start; i < start+5; i++ {
				mockBibliophile.EXPECT().GetSize(gomock.Any(), gomock.Any()).Return(big.NewInt(i)).Times(1)
				err := validateLimitOrderLike(mockBibliophile, &badOrder, filledAmount, Placed, Short, fillAmount)
				assert.Nil(t, err)
			}
		})

		t.Run("all conditions met", func(t *testing.T) {
			err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Short, fillAmount)
			assert.Nil(t, err)
		})
	})

	t.Run("invalid side", func(t *testing.T) {
		order := &hu.BaseOrder{
			AmmIndex:          big.NewInt(0),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		}
		filledAmount := big.NewInt(0)
		fillAmount := big.NewInt(5)

		err := validateLimitOrderLike(mockBibliophile, order, filledAmount, Placed, Side(4), fillAmount) // assuming 4 is an invalid Side value
		assert.EqualError(t, err, "invalid side")
	})
}

func TestValidateExecuteSignedOrder(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	t.Run("validateExecuteSignedOrder - long", func(t *testing.T) {
		hu.SetChainIdAndVerifyingSignedOrdersContract(321123, "0x4c5859f0F772848b2D91F1D83E2Fe57935348029")
		orderHash := strings.TrimPrefix("0x73d5196ac9576efaccb6e54b193b894e2cc0afd68ce5af519c901fec7e588595", "0x")
		signature := strings.TrimPrefix("0x3027ae4ab98663490d0facab04c71665e41da867a44b7ddc29e14cb8de3a3cfa12985be54945ce040196b2fcdcc4dafc56f7955ee72628bc9e7a634a7f258ce61c", "0x")
		sig, err := hex.DecodeString(signature)
		assert.Nil(t, err)
		order := &hu.SignedOrder{
			LimitOrder: hu.LimitOrder{
				BaseOrder: hu.BaseOrder{
					AmmIndex:          big.NewInt(0),
					Trader:            common.HexToAddress("0x70997970C51812dc3A010C7d01b50e0d17dc79C8"),
					BaseAssetQuantity: big.NewInt(5000000000000000000), // 5
					Price:             big.NewInt(1000000000),
					Salt:              big.NewInt(1688994806105),
					ReduceOnly:        false,
				},
				PostOnly: true,
			},
			OrderType: 2,
			ExpireAt:  big.NewInt(1688994854),
			Sig:       sig,
		}
		filledAmount := big.NewInt(2000000000000000000) // 2
		fillAmount := big.NewInt(3000000000000000000)   // 3
		testValidateExecuteSignedOrder(t, mockBibliophile, order, orderHash, Long, fillAmount, filledAmount)
	})

	t.Run("validateExecuteSignedOrder - short", func(t *testing.T) {
		hu.SetChainIdAndVerifyingSignedOrdersContract(321123, "0x809d550fca64d94Bd9F66E60752A544199cfAC3D")
		orderHash := strings.TrimPrefix("0xee4b26ae386d1c88f89eb2f8b4b4205271576742f5ff4e0488633612f7a9a5e7", "0x")
		signature := strings.TrimPrefix("0xb2704b73b99f2700ecc90a218f514c254d1f5d46af47117f5317f6cc0348ce962dcfb024c7264fdeb1f1513e4564c2a7cd9c1d0be33d7b934cd5a73b96440eaf1c", "0x")
		sig, err := hex.DecodeString(signature)
		assert.Nil(t, err)
		order := &hu.SignedOrder{
			LimitOrder: hu.LimitOrder{
				BaseOrder: hu.BaseOrder{
					AmmIndex:          big.NewInt(0),
					Trader:            common.HexToAddress("0x70997970C51812dc3A010C7d01b50e0d17dc79C8"),
					BaseAssetQuantity: big.NewInt(-5000000000000000000), // -5
					Price:             big.NewInt(1000000000),
					Salt:              big.NewInt(1688994806105),
					ReduceOnly:        false,
				},
				PostOnly: true,
			},
			OrderType: 2,
			ExpireAt:  big.NewInt(1688994854),
			Sig:       sig,
		}
		filledAmount := big.NewInt(-2000000000000000000) // -2
		fillAmount := big.NewInt(-3000000000000000000)   // -3
		testValidateExecuteSignedOrder(t, mockBibliophile, order, orderHash, Short, fillAmount, filledAmount)
	})

	// t.Run("validateExecuteLimitOrder returns orderHash even when validation fails", func(t *testing.T) {
	// 	orderHash, err := order.Hash()
	// 	assert.Nil(t, err)

	// 	mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(filledAmount).Times(1)
	// 	mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(2)).Times(1) // Filled

	// 	m, err := validateExecuteLimitOrder(mockBibliophile, order, Long, fillAmount)
	// 	assert.EqualError(t, err, ErrInvalidOrder.Error())
	// 	assert.Equal(t, orderHash, m.OrderHash)
	// })
}

func testValidateExecuteSignedOrder(t *testing.T, mockBibliophile *b.MockBibliophileClient, order *hu.SignedOrder, orderHash string, side Side, fillAmount, filledAmount *big.Int) {
	h, err := order.Hash()
	assert.Nil(t, err)
	assert.Equal(t, orderHash, strings.TrimPrefix(h.Hex(), "0x"))

	encodedOrder, err := order.EncodeToABIWithoutType()
	assert.Nil(t, err)

	marketAddress := common.HexToAddress("0xa72b463C21dA61cCc86069cFab82e9e8491152a0")
	mockBibliophile.EXPECT().GetTimeStamp().Return(order.ExpireAt.Uint64()).Times(1)
	mockBibliophile.EXPECT().GetActiveMarketsCount().Return(int64(1)).Times(1)
	mockBibliophile.EXPECT().GetMinSizeRequirement(order.AmmIndex.Int64()).Return(big.NewInt(1e18))
	mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(marketAddress).Times(2)
	mockBibliophile.EXPECT().GetPriceMultiplier(marketAddress).Return(big.NewInt(1e6))
	mockBibliophile.EXPECT().GetSignedOrderStatus(h).Return(int64(0)).Times(1) // Invalid
	mockBibliophile.EXPECT().GetSignedOrderFilledAmount(h).Return(filledAmount).Times(1)
	mockBibliophile.EXPECT().HasReferrer(order.Trader).Return(true).Times(1)

	m, err := validateOrder(mockBibliophile, ob.Signed, encodedOrder, side, fillAmount)
	assert.Nil(t, err)
	assertMetadataEquality(t, &Metadata{
		AmmIndex:          new(big.Int).Set(order.AmmIndex),
		Trader:            order.Trader,
		BaseAssetQuantity: new(big.Int).Set(order.BaseAssetQuantity),
		BlockPlaced:       big.NewInt(0),
		Price:             new(big.Int).Set(order.Price),
		OrderHash:         h,
		OrderType:         ob.Signed,
		PostOnly:          true,
	}, m)
}

func TestValidateExecuteLimitOrder(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)
	marketAddress := common.HexToAddress("0xa72b463C21dA61cCc86069cFab82e9e8491152a0")
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")

	order := &hu.LimitOrder{
		BaseOrder: hu.BaseOrder{
			AmmIndex:          big.NewInt(534),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		},
		PostOnly: false,
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("validateExecuteLimitOrder", func(t *testing.T) {
		orderHash, err := order.Hash()
		assert.Nil(t, err)
		encodedOrder, err := order.EncodeToABIWithoutType()
		assert.Nil(t, err)

		blockPlaced := big.NewInt(42)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(filledAmount).Times(1)
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)).Times(1)                                 // placed
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(blockPlaced).Times(1)                              // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(marketAddress).Times(1) // placed

		m, err := validateOrder(mockBibliophile, ob.Limit, encodedOrder, Long, fillAmount)
		assert.Nil(t, err)
		assertMetadataEquality(t, &Metadata{
			AmmIndex:          new(big.Int).Set(order.AmmIndex),
			Trader:            trader,
			BaseAssetQuantity: new(big.Int).Set(order.BaseAssetQuantity),
			BlockPlaced:       blockPlaced,
			Price:             new(big.Int).Set(order.Price),
			OrderHash:         orderHash,
		}, m)
	})

	t.Run("validateExecuteLimitOrder returns orderHash even when validation fails", func(t *testing.T) {
		orderHash, err := order.Hash()
		assert.Nil(t, err)
		encodedOrder, err := order.EncodeToABIWithoutType()
		assert.Nil(t, err)

		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(filledAmount).Times(1)
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(2)).Times(1) // Filled

		m, err := validateOrder(mockBibliophile, ob.Limit, encodedOrder, Long, fillAmount)
		assert.EqualError(t, err, ErrInvalidOrder.Error())
		assert.Equal(t, orderHash, m.OrderHash)
	})
}

func TestValidateExecuteIOCOrder(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)
	marketAddress := common.HexToAddress("0xa72b463C21dA61cCc86069cFab82e9e8491152a0")
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")

	order := &hu.IOCOrder{
		BaseOrder: hu.BaseOrder{
			AmmIndex:          big.NewInt(534),
			Trader:            trader,
			BaseAssetQuantity: big.NewInt(10),
			Price:             big.NewInt(20),
			Salt:              big.NewInt(1),
			ReduceOnly:        false,
		},
		OrderType: uint8(ob.IOC),
		ExpireAt:  big.NewInt(65),
	}
	filledAmount := big.NewInt(5)
	fillAmount := big.NewInt(5)

	t.Run("validateExecuteIOCOrder success", func(t *testing.T) {
		orderHash, err := order.Hash()
		assert.Nil(t, err)
		encodedOrder, err := order.EncodeToABIWithoutType()
		assert.Nil(t, err)

		blockPlaced := big.NewInt(42)
		mockBibliophile.EXPECT().IOC_GetOrderFilledAmount(orderHash).Return(filledAmount).Times(1)
		mockBibliophile.EXPECT().IOC_GetOrderStatus(orderHash).Return(int64(1)).Times(1)                             // placed
		mockBibliophile.EXPECT().IOC_GetBlockPlaced(orderHash).Return(blockPlaced).Times(1)                          // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(marketAddress).Times(1) // placed
		mockBibliophile.EXPECT().GetTimeStamp().Return(uint64(60)).Times(1)                                          // placed

		m, err := validateOrder(mockBibliophile, ob.IOC, encodedOrder, Long, fillAmount)
		assert.Nil(t, err)
		assertMetadataEquality(t, &Metadata{
			AmmIndex:          new(big.Int).Set(order.AmmIndex),
			Trader:            trader,
			BaseAssetQuantity: new(big.Int).Set(order.BaseAssetQuantity),
			BlockPlaced:       blockPlaced,
			Price:             new(big.Int).Set(order.Price),
			OrderHash:         orderHash,
		}, m)
	})

	t.Run("validateExecuteIOCOrder not ioc order", func(t *testing.T) {
		order.OrderType = uint8(ob.Limit)
		orderHash, err := order.Hash()
		assert.Nil(t, err)
		encodedOrder, err := order.EncodeToABIWithoutType()
		assert.Nil(t, err)

		m, err := validateOrder(mockBibliophile, ob.IOC, encodedOrder, Long, fillAmount)
		assert.NotNil(t, err)
		assert.Equal(t, err.Error(), "not ioc order")
		assert.Equal(t, m.OrderHash, orderHash)
	})

	t.Run("validateExecuteIOCOrder order expires", func(t *testing.T) {
		order.OrderType = uint8(ob.IOC)
		orderHash, err := order.Hash()
		assert.Nil(t, err)
		encodedOrder, err := order.EncodeToABIWithoutType()
		assert.Nil(t, err)

		mockBibliophile.EXPECT().GetTimeStamp().Return(uint64(66)).Times(1)

		m, err := validateOrder(mockBibliophile, ob.IOC, encodedOrder, Long, fillAmount)
		assert.NotNil(t, err)
		assert.Equal(t, err.Error(), "ioc expired")
		assert.Equal(t, m.OrderHash, orderHash)
	})
}

func assertMetadataEquality(t *testing.T, expected, actual *Metadata) {
	assert.Equal(t, expected.AmmIndex.Int64(), actual.AmmIndex.Int64())
	assert.Equal(t, expected.Trader, actual.Trader)
	assert.Equal(t, expected.BaseAssetQuantity, actual.BaseAssetQuantity)
	assert.Equal(t, expected.BlockPlaced, actual.BlockPlaced)
	assert.Equal(t, expected.Price, actual.Price)
	assert.Equal(t, expected.OrderHash, actual.OrderHash)
}

func TestDetermineFillPrice(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	oraclePrice := hu.Mul1e6(big.NewInt(20))                                                               // $20
	spreadLimit := new(big.Int).Mul(big.NewInt(50), big.NewInt(1e4))                                       // 50%
	upperbound := hu.Div1e6(new(big.Int).Mul(oraclePrice, new(big.Int).Add(big.NewInt(1e6), spreadLimit))) // $10
	lowerbound := hu.Div1e6(new(big.Int).Mul(oraclePrice, new(big.Int).Sub(big.NewInt(1e6), spreadLimit))) // $30
	market := int64(5)

	t.Run("long order came first", func(t *testing.T) {
		blockPlaced0 := big.NewInt(69)
		blockPlaced1 := big.NewInt(70)
		t.Run("long price < lower bound", func(t *testing.T) {
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(9)),
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(8)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooLow, err)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(7)),
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       hu.Mul1e6(big.NewInt(7)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooLow, err)
			})
		})

		t.Run("long price == lower bound", func(t *testing.T) {
			longPrice := lowerbound
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("lowerbound < long price < oracle", func(t *testing.T) {
			longPrice := hu.Mul1e6(big.NewInt(15))
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("long price == oracle", func(t *testing.T) {
			longPrice := oraclePrice
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("oracle < long price < upper bound", func(t *testing.T) {
			longPrice := hu.Mul1e6(big.NewInt(25))
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("long price == upper bound", func(t *testing.T) {
			longPrice := upperbound
			t.Run("short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(longPrice, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})

			t.Run("short price == long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       longPrice,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{longPrice, Maker, Taker}, *output)
			})
		})

		t.Run("upper bound < long price", func(t *testing.T) {
			longPrice := new(big.Int).Add(upperbound, big.NewInt(42))
			t.Run("upper < short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Add(upperbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, output)
				assert.Equal(t, ErrTooHigh, err)
			})

			t.Run("upper == short price < long price", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       upperbound,
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})

			t.Run("short price < upper", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(upperbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})

			t.Run("short price < lower", func(t *testing.T) {
				m0 := &Metadata{
					Price:       longPrice,
					AmmIndex:    big.NewInt(market),
					BlockPlaced: blockPlaced0,
				}
				m1 := &Metadata{
					Price:       new(big.Int).Sub(lowerbound, big.NewInt(1)),
					BlockPlaced: blockPlaced1,
				}
				mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
				output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
				assert.Nil(t, err)
				assert.Equal(t, FillPriceAndModes{upperbound, Maker, Taker}, *output)
			})
		})
	})

	t.Run("short order came first", func(t *testing.T) {
		blockPlaced0 := big.NewInt(70)
		blockPlaced1 := big.NewInt(69)
		t.Run("short price < long price", func(t *testing.T) {
			m0 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(20)),
				AmmIndex:    big.NewInt(market),
				BlockPlaced: blockPlaced0,
			}
			m1 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				BlockPlaced: blockPlaced1,
			}
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
			assert.Nil(t, err)
			assert.Equal(t, FillPriceAndModes{m1.Price, Taker, Maker}, *output)
		})
		t.Run("short order is IOC", func(t *testing.T) {
			m0 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(20)),
				AmmIndex:    big.NewInt(market),
				BlockPlaced: blockPlaced0,
			}
			m1 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				BlockPlaced: blockPlaced1,
				OrderType:   ob.IOC,
			}
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err, errorOrder := determineFillPrice(mockBibliophile, m0, m1)
			assert.Nil(t, output)
			assert.Equal(t, ErrIOCOrderExpired, err)
			assert.Equal(t, Order1, errorOrder)
		})
		t.Run("long order is post only", func(t *testing.T) {
			m0 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(20)),
				AmmIndex:    big.NewInt(market),
				BlockPlaced: blockPlaced0,
				OrderType:   ob.Limit,
				PostOnly:    true,
			}
			m1 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				BlockPlaced: blockPlaced1,
			}
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err, errorOrder := determineFillPrice(mockBibliophile, m0, m1)
			assert.Nil(t, output)
			assert.Equal(t, ErrCrossingMarket, err)
			assert.Equal(t, Order0, errorOrder)
		})
	})
	t.Run("both orders in the same block", func(t *testing.T) {
		blockPlaced0 := big.NewInt(69)
		blockPlaced1 := big.NewInt(69)
		t.Run("short order = IOC", func(t *testing.T) {
			m0 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				AmmIndex:    big.NewInt(market),
				BlockPlaced: blockPlaced0,
			}
			m1 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				BlockPlaced: blockPlaced1,
				OrderType:   ob.IOC,
			}
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
			assert.Nil(t, err)
			assert.Equal(t, FillPriceAndModes{m0.Price, Maker, Taker}, *output)
		})
		t.Run("short order != IOC", func(t *testing.T) {
			m0 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				AmmIndex:    big.NewInt(market),
				BlockPlaced: blockPlaced0,
			}
			m1 := &Metadata{
				Price:       hu.Mul1e6(big.NewInt(19)),
				BlockPlaced: blockPlaced1,
			}
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err, _ := determineFillPrice(mockBibliophile, m0, m1)
			assert.Nil(t, err)
			assert.Equal(t, FillPriceAndModes{m1.Price, Taker, Maker}, *output)
		})
	})
}

func TestDetermineLiquidationFillPrice(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)

	liqUpperBound, liqLowerBound := hu.Mul1e6(big.NewInt(22)), hu.Mul1e6(big.NewInt(18))

	upperbound := hu.Mul1e6(big.NewInt(30)) // $30
	lowerbound := hu.Mul1e6(big.NewInt(10)) // $10
	market := int64(7)

	t.Run("long position is being liquidated", func(t *testing.T) {
		t.Run("order price < liqLowerBound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Sub(liqLowerBound, big.NewInt(1)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, output)
			assert.Equal(t, ErrTooLow, err)
		})
		t.Run("order price == liqLowerBound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             liqLowerBound,
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, liqLowerBound, output)
		})

		t.Run("liqLowerBound < order price < upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Add(liqLowerBound, big.NewInt(99)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, m0.Price, output)
		})

		t.Run("order price == upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             upperbound,
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, upperbound, output)
		})

		t.Run("order price > upper bound", func(t *testing.T) {
			m0 := &Metadata{
				Price:             new(big.Int).Add(upperbound, big.NewInt(99)),
				BaseAssetQuantity: big.NewInt(5),
				AmmIndex:          big.NewInt(market),
			}
			mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(market).Return(liqUpperBound, liqLowerBound).Times(1)
			mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(market).Return(upperbound, lowerbound).Times(1)
			output, err := determineLiquidationFillPrice(mockBibliophile, m0)
			assert.Nil(t, err)
			assert.Equal(t, upperbound, output)
		})
	})
}

type ValidateOrdersAndDetermineFillPriceTestCase struct {
	Order0, Order1 ob.ContractOrder
	FillAmount     *big.Int
	Err            error
	BadElement     BadElement
}

func testValidateOrdersAndDetermineFillPriceTestCase(t *testing.T, mockBibliophile *b.MockBibliophileClient, testCase ValidateOrdersAndDetermineFillPriceTestCase) ValidateOrdersAndDetermineFillPriceOutput {
	order0Bytes, err := testCase.Order0.EncodeToABI()
	if err != nil {
		t.Fatal(err)
	}
	order1Bytes, err := testCase.Order1.EncodeToABI()
	if err != nil {
		t.Fatal(err)
	}
	resp := ValidateOrdersAndDetermineFillPrice(mockBibliophile, &ValidateOrdersAndDetermineFillPriceInput{
		Data:       [2][]byte{order0Bytes, order1Bytes},
		FillAmount: testCase.FillAmount,
	})

	// verify results
	if testCase.Err == nil && resp.Err != "" {
		t.Fatalf("expected no error, got %v", resp.Err)
	}
	if testCase.Err != nil {
		if resp.Err != testCase.Err.Error() {
			t.Fatalf("expected %v, got %v", testCase.Err, testCase.Err)
		}

		if resp.Element != uint8(testCase.BadElement) {
			t.Fatalf("expected %v, got %v", testCase.BadElement, resp.Element)
		}
	}
	return resp
}

func TestValidateOrdersAndDetermineFillPrice(t *testing.T) {
	// create a mock BibliophileClient
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	t.Run("invalid fillAmount", func(t *testing.T) {
		order0 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		fillAmount := big.NewInt(0)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrInvalidFillAmount,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("different amm", func(t *testing.T) {
		order0 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(1),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{102})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))
		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrNotSameAMM,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("price mismatch", func(t *testing.T) {
		order0 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(99),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))
		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrNoMatch,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("fillAmount not multiple", func(t *testing.T) {
		order0 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))

		mockBibliophile.EXPECT().GetMinSizeRequirement(order1.AmmIndex.Int64()).Return(big.NewInt(5))

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrNotMultiple,
			BadElement: Generic,
		}

		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("success", func(t *testing.T) {
		order0 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order0Hash, _ := order0.Hash()
		order1 := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			PostOnly: false,
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(order1Hash).Return(big.NewInt(12))

		mockBibliophile.EXPECT().GetMinSizeRequirement(order1.AmmIndex.Int64()).Return(big.NewInt(1))
		mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(order1.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        nil,
			BadElement: NoError,
		}

		response := testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
		assert.Equal(t, big.NewInt(100), response.Res.FillPrice)
		assert.Equal(t, uint8(0), response.Res.OrderTypes[0])
		assert.Equal(t, uint8(0), response.Res.OrderTypes[1])

		assert.Equal(t, uint8(NoError), response.Element)
		assert.Equal(t, IClearingHouseInstruction{
			AmmIndex:  big.NewInt(0),
			Trader:    trader,
			OrderHash: order0Hash,
			Mode:      uint8(Maker),
		}, response.Res.Instructions[0])
		assert.Equal(t, IClearingHouseInstruction{
			AmmIndex:  big.NewInt(0),
			Trader:    trader,
			OrderHash: order1Hash,
			Mode:      uint8(Taker),
		}, response.Res.Instructions[1])
	})

	t.Run("2 market orders can't be matched", func(t *testing.T) {
		order0 := &hu.IOCOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        false,
			},
			OrderType: 1,
			ExpireAt:  big.NewInt(100),
		}
		order0Hash, _ := order0.Hash()
		order1 := &hu.IOCOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        false,
			},
			OrderType: 1,
			ExpireAt:  big.NewInt(100),
		}
		order1Hash, _ := order1.Hash()
		fillAmount := big.NewInt(2)

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().IOC_GetOrderFilledAmount(order0Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().IOC_GetOrderStatus(order0Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order0.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().IOC_GetBlockPlaced(order0Hash).Return(big.NewInt(10))

		mockBibliophile.EXPECT().IOC_GetOrderFilledAmount(order1Hash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().IOC_GetOrderStatus(order1Hash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order1.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().IOC_GetBlockPlaced(order1Hash).Return(big.NewInt(12))
		mockBibliophile.EXPECT().GetTimeStamp().Times(2).Return(uint64(99)) // expiry is 100

		mockBibliophile.EXPECT().GetMinSizeRequirement(order1.AmmIndex.Int64()).Return(big.NewInt(1))
		mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(order1.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))

		testCase := ValidateOrdersAndDetermineFillPriceTestCase{
			Order0:     order0,
			Order1:     order1,
			FillAmount: fillAmount,
			Err:        ErrIOCOrderExpired,
			BadElement: Order0,
		}
		testValidateOrdersAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})
}

type ValidateLiquidationOrderAndDetermineFillPriceTestCase struct {
	Order             ob.ContractOrder
	LiquidationAmount *big.Int
	Err               error
	BadElement        BadElement
}

func testValidateLiquidationOrderAndDetermineFillPriceTestCase(t *testing.T, mockBibliophile *b.MockBibliophileClient, testCase ValidateLiquidationOrderAndDetermineFillPriceTestCase) ValidateLiquidationOrderAndDetermineFillPriceOutput {
	orderBytes, err := testCase.Order.EncodeToABI()
	if err != nil {
		t.Fatal(err)
	}

	resp := ValidateLiquidationOrderAndDetermineFillPrice(mockBibliophile, &ValidateLiquidationOrderAndDetermineFillPriceInput{
		Data:              orderBytes,
		LiquidationAmount: testCase.LiquidationAmount,
	})

	// verify results
	if testCase.Err == nil && resp.Err != "" {
		t.Fatalf("expected no error, got %v", resp.Err)
	}
	if testCase.Err != nil {
		if resp.Err != testCase.Err.Error() {
			t.Fatalf("expected %v, got %v", testCase.Err, testCase.Err)
		}

		if resp.Element != uint8(testCase.BadElement) {
			t.Fatalf("expected %v, got %v", testCase.BadElement, resp.Element)
		}
	}
	return resp
}

func TestValidateLiquidationOrderAndDetermineFillPrice(t *testing.T) {
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	t.Run("invalid liquidationAmount", func(t *testing.T) {
		order := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(1),
				ReduceOnly:        true,
			},
			PostOnly: false,
		}

		mockBibliophile := b.NewMockBibliophileClient(ctrl)

		testCase := ValidateLiquidationOrderAndDetermineFillPriceTestCase{
			Order:             order,
			LiquidationAmount: big.NewInt(0),
			Err:               ErrInvalidFillAmount,
			BadElement:        Generic,
		}

		testValidateLiquidationOrderAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("fillAmount not multiple", func(t *testing.T) {
		order := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        true,
			},
			PostOnly: false,
		}
		orderHash, _ := order.Hash()

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(big.NewInt(10))
		mockBibliophile.EXPECT().GetSize(common.Address{101}, &trader).Return(big.NewInt(10))

		mockBibliophile.EXPECT().GetMinSizeRequirement(order.AmmIndex.Int64()).Return(big.NewInt(5))

		testCase := ValidateLiquidationOrderAndDetermineFillPriceTestCase{
			Order:             order,
			LiquidationAmount: big.NewInt(2),
			Err:               ErrNotMultiple,
			BadElement:        Generic,
		}

		testValidateLiquidationOrderAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)
	})

	t.Run("success", func(t *testing.T) {
		order := &hu.LimitOrder{
			BaseOrder: hu.BaseOrder{
				AmmIndex:          big.NewInt(0),
				Trader:            trader,
				BaseAssetQuantity: big.NewInt(-10),
				Price:             big.NewInt(100),
				Salt:              big.NewInt(2),
				ReduceOnly:        true,
			},
			PostOnly: false,
		}
		orderHash, _ := order.Hash()

		mockBibliophile := b.NewMockBibliophileClient(ctrl)
		mockBibliophile.EXPECT().GetOrderFilledAmount(orderHash).Return(big.NewInt(0))
		mockBibliophile.EXPECT().GetOrderStatus(orderHash).Return(int64(1)) // placed
		mockBibliophile.EXPECT().GetMarketAddressFromMarketID(order.AmmIndex.Int64()).Return(common.Address{101})
		mockBibliophile.EXPECT().GetBlockPlaced(orderHash).Return(big.NewInt(10))
		mockBibliophile.EXPECT().GetSize(common.Address{101}, &trader).Return(big.NewInt(10))
		mockBibliophile.EXPECT().GetMinSizeRequirement(order.AmmIndex.Int64()).Return(big.NewInt(1))
		mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(order.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))
		mockBibliophile.EXPECT().GetAcceptableBoundsForLiquidation(order.AmmIndex.Int64()).Return(big.NewInt(110), big.NewInt(90))

		testCase := ValidateLiquidationOrderAndDetermineFillPriceTestCase{
			Order:             order,
			LiquidationAmount: big.NewInt(2),
			Err:               nil,
			BadElement:        NoError,
		}

		response := testValidateLiquidationOrderAndDetermineFillPriceTestCase(t, mockBibliophile, testCase)

		assert.Equal(t, uint8(NoError), response.Element)
		assert.Equal(t, IClearingHouseInstruction{
			AmmIndex:  big.NewInt(0),
			Trader:    trader,
			OrderHash: orderHash,
			Mode:      uint8(Maker),
		}, response.Res.Instruction)
		assert.Equal(t, big.NewInt(100), response.Res.FillPrice)
		assert.Equal(t, uint8(0), response.Res.OrderType)
		assert.Equal(t, big.NewInt(-2), response.Res.FillAmount)
	})
}

func TestReducesPosition(t *testing.T) {
	testCases := []struct {
		positionSize      *big.Int
		baseAssetQuantity *big.Int
		expectedResult    bool
	}{
		{
			positionSize:      big.NewInt(100),
			baseAssetQuantity: big.NewInt(-50),
			expectedResult:    true,
		},
		{
			positionSize:      big.NewInt(-100),
			baseAssetQuantity: big.NewInt(50),
			expectedResult:    true,
		},
		{
			positionSize:      big.NewInt(100),
			baseAssetQuantity: big.NewInt(50),
			expectedResult:    false,
		},
		{
			positionSize:      big.NewInt(-100),
			baseAssetQuantity: big.NewInt(-50),
			expectedResult:    false,
		},
	}

	for _, tc := range testCases {
		result := reducesPosition(tc.positionSize, tc.baseAssetQuantity)
		if result != tc.expectedResult {
			t.Errorf("reducesPosition(%v, %v) = %v; expected %v", tc.positionSize, tc.baseAssetQuantity, result, tc.expectedResult)
		}
	}
}

func TestGetRequiredMargin(t *testing.T) {
	trader := common.HexToAddress("0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockBibliophile := b.NewMockBibliophileClient(ctrl)
	mockBibliophile.EXPECT().GetUpperAndLowerBoundForMarket(gomock.Any()).Return(big.NewInt(100), big.NewInt(10)).AnyTimes()
	mockBibliophile.EXPECT().GetMinAllowableMargin().Return(big.NewInt(1000)).AnyTimes()
	mockBibliophile.EXPECT().GetTakerFee().Return(big.NewInt(5)).AnyTimes()

	// create a mock order
	order := ILimitOrderBookOrder{
		AmmIndex:          big.NewInt(0),
		Trader:            trader,
		BaseAssetQuantity: hu.Mul(big.NewInt(10), hu.ONE_E_18),
		Price:             hu.Mul(big.NewInt(50), hu.ONE_E_6),
		ReduceOnly:        false,
		Salt:              big.NewInt(1),
		PostOnly:          false,
	}

	// call the function
	requiredMargin := getRequiredMargin(mockBibliophile, order)

	fmt.Println("#####", requiredMargin)

	// assert that the result is correct
	expectedMargin := big.NewInt(502500) // (10 * 50 * 1e6) * (1 + 0.005)
	assert.Equal(t, expectedMargin, requiredMargin)
}
